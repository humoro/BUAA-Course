#### 符号表中需要添加的表项内容：
符号表中需要维护表项的元素有：函数，变量声明，常量的声明

* 通用表项：
  * 名字
  * 类型（`const int;const char;int;char `,函数）
  * 声明行
  * 引用行（引用的地方不止一处）
  * *地址（本次不添加）
* 函数特有：
  * 函数的参数表
* 数组特有：(文法中数组的维数只可能是一维)
  * 数组的维数
  

 由于只有复合语句中才会有变量的声明，所以对于每个变量查看是否定义只需要记录其所属于的复合语句块

 而复合语句块要么属于主函数要么属于定义的函数，其名称是不能重复的,对于错误处理中重复的函数名称采用加'.'和数字的方式先进行区别（从0开始）

 对于函数名称重复的函数调用的时候都默认调用最先解析出的函数

 对于函数的参数表中不能出现数组类型

 函数参数表中不能出现`const`类型

### 关于错误处理的一些约定：

#### a. 非法符号和不符合词法：

1. 出现词法规则里不允许出现的符号
2. <font color = red>solve </font>在定义字符的时候，同一行中没有找到配对的右单引号
3. <font color = red>solve </font>在定义字符串的时候，同一行中没有找到配对的右双引号 

#### <font color = red>solve </font>b. 名字重定义：

**对于重定义的标识符**：

* 如果是变量的标识符：按照第一次定义的标识符类型处理（即发现重定义变量只需要报错而不需要添加符号表）
* 如果是函数中的参数表中的重定义：对于名称重定义的变量需要报重定义的错误，但是函数调用的时候按照两个参数处理（即函数调用的时候只需要匹配类型和个数）
* 对于函数重定义处理方法类似于变量标识符：只保留第一次定义的函数

#### <font color = red>solve </font>c. 未定义的名字：

#### <font color = red>solve </font>d. 函数的参数个数不匹配

#### <font color = red>solve </font>e. 函数参数类型不匹配

#### <font color = red>solve </font>f. 条件判断中出现不合法类型

#### <font color = red>solve </font>g.无返回值的函数存在不匹配的`return`语句

#### <font color = red>solve </font>h.有返回值的函数缺少`return`语句或存在不匹配的`return`语句:

* 对于一个返回值函数无返回语句，报错行数为函数结束行，返回类型的错误报错在`return`语句行

* 测试程序中的每个分支保证有返回语句

#### <font color = red>solve </font>i. 数组的元素下表只能是**整型**表达式：

* 只需要考虑在引用数组元素的时候的错误

* 只需要检查下标的类型，不需要越界检查（即保证下标是整数即可）

#### <font color = red>solve </font>j.不能改变常量的值（包含了赋值语句，循环）

#### <font color = red>solve </font>k.应为分号

#### <font color = red>solve </font>l.应为右小括号`')'`

#### <font color = red>solve </font>m.应为右中括号`']'`

#### <font color = red>solve </font>n.`do-while`语句中缺少`while`

#### <font color = red>solve </font>o.常量定义中等号后面只能是**整型**或者字符型常量：

* 并且要求等号后面的数据类型是和前面定义的类型相符合即数字和字符不能自动转化

**其他约定**：

测试程序中不会出现一条语句分属多行

 每行最多只有一个错误，每个文件有1，2或3个错误。 

1. 只在表达式计算中有类型转换，字符型一旦参与运算则转换成整型，包括小括号括起来的字符型，也算参与了运算，例如(‘c’)的结果是整型。
2. 其他情况，例如赋值、函数传参、`if/while`条件语句中关系比较要求类型完全匹配，并且＜条件＞中的关系比较只能是整型之间比，不能是字符型，`if ‘(’＜条件＞‘)’`和`while ‘(’＜条件＞‘)’`里边，如果<条件>是单个表达式，则必须是整型。 

